<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前端技术指南 | 前端技术指南</title>
    <meta name="description" content="前端规范">
    <link rel="stylesheet" href="/vue3-admin-boilerplate/assets/style.71b4e378.css">
    <link rel="modulepreload" href="/vue3-admin-boilerplate/assets/app.1cd7dc09.js">
    <link rel="modulepreload" href="/vue3-admin-boilerplate/assets/other_前端规范是什么.md.52fcf658.lean.js">
    
    <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-57716dfc><!--[--><!--]--><!--[--><span tabindex="-1" data-v-f31c8439></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-f31c8439> Skip to content </a><!--]--><!----><header class="VPNav" data-v-57716dfc data-v-c07d7d69><div class="VPNavBar has-sidebar" data-v-c07d7d69 data-v-02cdc65f><div class="container" data-v-02cdc65f><div class="VPNavBarTitle has-sidebar" data-v-02cdc65f data-v-584c78db><a class="title" href="/vue3-admin-boilerplate/" data-v-584c78db><!--[--><!--]--><!----><!--[-->前端技术指南<!--]--><!--[--><!--]--></a></div><div class="content" data-v-02cdc65f><!--[--><!--]--><!----><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-02cdc65f data-v-29823991><span id="main-nav-aria-label" class="visually-hidden" data-v-29823991>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vue3-admin-boilerplate/guid/index.html" data-v-29823991 data-v-0470a9bd data-v-fb87878c><!--[-->首页<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vue3-admin-boilerplate/standard/index.html" data-v-29823991 data-v-0470a9bd data-v-fb87878c><!--[-->规范指南<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vue3-admin-boilerplate/basic/index.html" data-v-29823991 data-v-0470a9bd data-v-fb87878c><!--[-->基础配置<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vue3-admin-boilerplate/recommend/index.html" data-v-29823991 data-v-0470a9bd data-v-fb87878c><!--[-->选型指南<!--]--><!----></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/vue3-admin-boilerplate/other/index.html" data-v-29823991 data-v-0470a9bd data-v-fb87878c><!--[-->其他<!--]--><!----></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-02cdc65f data-v-a577059d><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-a577059d data-v-63aa3d04 data-v-a44d1a1a><span class="check" data-v-a44d1a1a><span class="icon" data-v-a44d1a1a><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-63aa3d04><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-63aa3d04><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-02cdc65f data-v-8a66a149 data-v-73db0514><!--[--><a class="VPSocialLink" href="https://github.com/hiliyongke/vue3-admin-boilerplate" target="_blank" rel="noopener" data-v-73db0514 data-v-2c010ba5><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-02cdc65f data-v-f89d77c3 data-v-33e15218><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-33e15218><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-33e15218><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-33e15218><div class="VPMenu" data-v-33e15218 data-v-5ec31f72><!----><!--[--><!--[--><!----><div class="group" data-v-f89d77c3><div class="item appearance" data-v-f89d77c3><p class="label" data-v-f89d77c3>Appearance</p><div class="appearance-action" data-v-f89d77c3><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" aria-label="toggle dark mode" aria-checked="false" data-v-f89d77c3 data-v-63aa3d04 data-v-a44d1a1a><span class="check" data-v-a44d1a1a><span class="icon" data-v-a44d1a1a><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-63aa3d04><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-63aa3d04><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><div class="group" data-v-f89d77c3><div class="item social-links" data-v-f89d77c3><div class="VPSocialLinks social-links-list" data-v-f89d77c3 data-v-73db0514><!--[--><a class="VPSocialLink" href="https://github.com/hiliyongke/vue3-admin-boilerplate" target="_blank" rel="noopener" data-v-73db0514 data-v-2c010ba5><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-02cdc65f data-v-0c720b6d><span class="container" data-v-0c720b6d><span class="top" data-v-0c720b6d></span><span class="middle" data-v-0c720b6d></span><span class="bottom" data-v-0c720b6d></span></span></button></div></div></div><!----></header><div class="VPLocalNav" data-v-57716dfc data-v-4024bfba><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-4024bfba><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="menu-icon" data-v-4024bfba><path d="M17,11H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,11,17,11z"></path><path d="M21,7H3C2.4,7,2,6.6,2,6s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,7,21,7z"></path><path d="M21,15H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h18c0.6,0,1,0.4,1,1S21.6,15,21,15z"></path><path d="M17,19H3c-0.6,0-1-0.4-1-1s0.4-1,1-1h14c0.6,0,1,0.4,1,1S17.6,19,17,19z"></path></svg><span class="menu-text" data-v-4024bfba>Menu</span></button><a class="top-link" href="#" data-v-4024bfba> Return to top </a></div><aside class="VPSidebar" data-v-57716dfc data-v-a24c1be4><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-a24c1be4><span class="visually-hidden" id="sidebar-aria-label" data-v-a24c1be4> Sidebar Navigation </span><!--[--><div class="group" data-v-a24c1be4><section class="VPSidebarGroup" data-v-a24c1be4 data-v-13b7ed25><div class="title" data-v-13b7ed25><h2 class="title-text" data-v-13b7ed25>引言</h2><div class="action" data-v-13b7ed25><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewbox="0 0 24 24" class="icon minus" data-v-13b7ed25><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2zM20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h8c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg><svg version="1.1" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon plus" data-v-13b7ed25><path d="M19,2H5C3.3,2,2,3.3,2,5v14c0,1.7,1.3,3,3,3h14c1.7,0,3-1.3,3-3V5C22,3.3,20.7,2,19,2z M20,19c0,0.6-0.4,1-1,1H5c-0.6,0-1-0.4-1-1V5c0-0.6,0.4-1,1-1h14c0.6,0,1,0.4,1,1V19z"></path><path d="M16,11h-3V8c0-0.6-0.4-1-1-1s-1,0.4-1,1v3H8c-0.6,0-1,0.4-1,1s0.4,1,1,1h3v3c0,0.6,0.4,1,1,1s1-0.4,1-1v-3h3c0.6,0,1-0.4,1-1S16.6,11,16,11z"></path></svg></div></div><div class="items" data-v-13b7ed25><!--[--><!--[--><a class="VPLink link link" href="/vue3-admin-boilerplate/other/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83.html" style="padding-left:0px;" data-v-bbc688c4 data-v-fb87878c><!--[--><span class="link-text" data-v-bbc688c4>怎么落实规范</span><!--]--><!----></a><!----><!--]--><!--]--></div></section></div><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-57716dfc data-v-8646b5e9><div class="VPDoc has-sidebar has-aside" data-v-8646b5e9 data-v-192b9b3b><div class="container" data-v-192b9b3b><div class="aside" data-v-192b9b3b><div class="aside-curtain" data-v-192b9b3b></div><div class="aside-container" data-v-192b9b3b><div class="aside-content" data-v-192b9b3b><div class="VPDocAside" data-v-192b9b3b data-v-ce88b067><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" data-v-ce88b067 data-v-7adc09cb><div class="content" data-v-7adc09cb><div class="outline-marker" data-v-7adc09cb></div><div class="outline-title" data-v-7adc09cb>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-7adc09cb><span class="visually-hidden" id="doc-outline-aria-label" data-v-7adc09cb> Table of Contents for current page </span><ul class="root" data-v-7adc09cb data-v-f93edfaf><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-ce88b067></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-192b9b3b><div class="content-container" data-v-192b9b3b><!--[--><!--]--><main class="main" data-v-192b9b3b><div style="position:relative;" class="vp-doc _vue3-admin-boilerplate_other_%E5%89%8D%E7%AB%AF%E8%A7%84%E8%8C%83%E6%98%AF%E4%BB%80%E4%B9%88" data-v-192b9b3b><div><p>笔者长期单枪匹马在前端领域厮杀 (言外之意就是团队就一个人)，自己就是规范。随着公司业务的扩展，扩充了一些人员，这时候就要开始考虑协作和编码规范问题了。本文记录了笔者在制定<code>前端协作规范</code>时的一些思考，希望能给你们也带来一些帮助.</p><p><strong>一个人走的更快，一群人可以走得更远，前提是统一的策略，还要不断地反省和优化</strong>。</p><p><strong>什么是规范?</strong></p><p>规范，名词意义上：即明文规定或约定俗成的标准，如：道德规范、技术规范等。 动词意义上：是指按照既定标准、规范的要求进行操作，使某一行为或活动达到或超越规定的标准，如：规范管理、规范操作.</p><p><strong>为什么需要规范?</strong></p><ul><li><p>降低新成员融入团队的成本, 同时也一定程度避免挖坑</p></li><li><p>提高开发效率、团队协作效率, 降低沟通成本</p></li><li><p>实现高度统一的代码风格，方便 review, 另外一方面可以提高项目的可维护性</p></li><li><p>规范是实现自动化的基础</p></li><li><p>规范是一个团队知识沉淀的直接输出</p></li></ul><p><strong>规范包含哪些内容?</strong></p><p>如文章标题，<strong>前端协作规范并不单单指‘编码规范’，这个规范涉及到前端开发活动的方方面面</strong>，例如代码库的管理、前后端协作、代码规范、兼容性规范；</p><p>不仅仅是前端团队内部需要协作，一个完整的软件生命周期内，我们需要和产品 / 设计、后端 (或者原生客户端团队)、测试进行协作, 我们需要覆盖这些内容.</p><p>下面就开始介绍，<strong>如果我是前端团队的 Leader，我会怎么制定前端规范，这个规范需要包含哪些内容</strong>?</p><h2 id="_1-工作流规范" tabindex="-1">1 工作流规范 <a class="header-anchor" href="#_1-工作流规范" aria-hidden="true">#</a></h2><h3 id="_1-1-开发" tabindex="-1">1.1 开发 <a class="header-anchor" href="#_1-1-开发" aria-hidden="true">#</a></h3><h4 id="_1-1-1-版本规范" tabindex="-1">1.1.1 版本规范 <a class="header-anchor" href="#_1-1-1-版本规范" aria-hidden="true">#</a></h4><p>项目的版本号应该根据某些规则进行迭代, 这里推荐使用语义化版本【<a href="https://semver.org/lang/zh-CN/%E3%80%91%E8%A7%84%E8%8C%83" target="_blank" rel="noreferrer">https://semver.org/lang/zh-CN/】规范</a>, <strong>通过这个规范，用户可以了解版本变更的影响范围</strong>。 规则如下:</p><ul><li><p>主版本号：当你做了不兼容的 API 修改，</p></li><li><p>次版本号：当你做了向下兼容的功能性新增，</p></li><li><p>修订号：当你做了向下兼容的问题修正。</p></li></ul><h4 id="_1-1-2-版本控制系统规范" tabindex="-1">1.1.2 版本控制系统规范 <a class="header-anchor" href="#_1-1-2-版本控制系统规范" aria-hidden="true">#</a></h4><p>大部分团队都使用 git 作为版本库，管理好代码也是一种学问。尤其是涉及多人并发协作、需要管理多个软件版本的情况下，定义良好的版本库管理规范，可以让大型项目更有组织性，也可以提高成员协作效率.</p><p>比较流行的 git 分支模型 / 工作流是 git-flow, 但是大部分团队会根据自己的情况制定自己的 git 工作流规范, 例如我们团队的分支规范</p><p><strong>Git 有很多工作流方法论，这些工作流的选择可能依赖于项目的规模、项目的类型以及团队成员的结构</strong>.</p><p>比如一个简单的个人项目可能不需要复杂的分支划分，我们的变更都是直接提交到 master 分支;</p><p>再比如开源项目，除了核心团队成员，其他贡献者是没有提交的权限的，而且我们也需要一定的手段来验证和讨论贡献的代码是否合理。 所以对于开源项目 fork 工作流更为适合.</p><p>了解常见的工作流有利于组织或创建适合自己团队的工作流, 提交团队协作的效率:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyKhkeyeticvIjVXCaKxQJLW2e7xP7VrtOwxEzcymcg3ias8FhKnnlzzUA/640?wx_fmt=png" alt=""></p><ul><li><p>简单的集中式</p></li><li><p>基于功能分支的工作流</p></li><li><p>Git Flow 🔥</p></li><li><p>Fork/Pull Request 工作流</p></li></ul><h4 id="_1-1-3-提交信息规范" tabindex="-1">1.1.3 提交信息规范 <a class="header-anchor" href="#_1-1-3-提交信息规范" aria-hidden="true">#</a></h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyVicRKg2HbA5wDP7e9Yfdj4fszraNFeXDpQaStnYLVt8n9QOZmkkTePQ/640?wx_fmt=png" alt=""></p><p>组织好的提交信息, 可以提高项目的整体质量. 至少具有下面这些优点:</p><ul><li><p><strong>格式统一的提交信息有助于自动化生成 CHANGELOG</strong></p></li><li><p><strong>版本库不只是存放代码的仓库, 它记录项目的开发日志, 它应该要清晰表达这次提交的做了什么</strong>. 这些记录应该可以帮助后来者快速地学习和回顾代码, 也应该方便其他协作者 review 你的代码</p></li><li><p><strong>规范化提交信息可以促进提交者提交有意义的、粒度合适的&#39;提交&#39;</strong>. 提交者要想好要怎么描述这个提交，这样被动促进了他们去把控<strong>提交的粒度</strong></p></li></ul><p>社区上比较流行的提交信息规范是 Angular 的提交信息规范, 除此之外，这些也很不错:</p><ul><li><p>Atom</p></li><li><p>Ember</p></li><li><p>Eslint</p></li><li><p>JQuery</p></li></ul><p>另外这些工具可以帮助你检验提交信息, 以及生成 CHANGELOG:</p><ul><li><p>conventional-changelog - 从项目的提交信息中生成 CHANGELOG 和发布信息</p></li><li><p>commitlint - 检验提交信息</p></li><li><p>commitizen - 🔥 简单的提交规范和提交帮助工具，推荐</p></li><li><p>standard-changelog - angular 风格的提交命令行工具</p></li></ul><h3 id="_1-2-构建规范" tabindex="-1">1.2 构建规范 <a class="header-anchor" href="#_1-2-构建规范" aria-hidden="true">#</a></h3><p>对于团队、或者需要维护多个项目场景，统一的构建工具链很重要, <strong>这套工具应该强调 &quot;约定大于配置&quot;，让开发者更专注于业务的开发</strong>。笔者在 &lt;为什么要用 vue-cli3?&gt; 文章中提出了<code>vue-cli3</code>更新有很多亮点，非常适合作为团队构建工具链的基础:</p><ul><li><p>** 首先这类工具是推崇&#39;约定大于配置&#39;**。即按照他们的规范，可以实现开箱即用，快速开发业务. 在团队协作中这点很重要，我们不推荐团队成员去关心又臭又长的 webpack 构建配置</p></li><li><p><strong><code>vue-cli3</code>抽离了<code>cli service层</code>，可以独立更新工具链</strong>。也就是说项目的构建脚本和配置在一个独立的 service 项目中维护，而不是像以前一样在每个项目目录下都有 webpack 配置和依赖. 这样做的好处是独立地、简单地升级整个构建链</p></li><li><p><strong>灵活的插件机制</strong>。对于团队的定制化构建应该封装到插件中，这样也可以实现独立的更新。</p></li></ul><p><strong>我们可以选择第三方 CLI, 当然也定制自己的构建链，按照上面说的这个构建链应该有以下特点</strong>:</p><ul><li><p><strong>强约定，体现团队的规范</strong>。首先它应该避免团队成员去关心或更改构建的配置细节，暴露最小化的配置接口。 <em>另外构建工具不仅仅是构建，通常它还会集成代码检查、测试等功能</em>。</p></li><li><p><strong>方便升级</strong>。尤其是团队需要维护多个项目场景, 这一点很有意义</p></li></ul><p>下面是社区上比较流行的构建工具. 当然，你也可以根据自己的团队情况开发自己的 CLI, 但是下面的工具依然很有<em>参考价值</em>：</p><ul><li><p>create-react-app - 🔥 零配置开始 React 开发</p></li><li><p>vue-cli - 🔥 零配置、渐进增强的项目构建 CLI</p></li><li><p>parcel - 零配置的 Web 应用打包工具</p></li><li><p>Fusebox - 高速易用的打包工具</p></li><li><p>microbundle - 零配置, 基于 Rollup，适合用于打包‘库’</p></li></ul><h3 id="_1-3-发布工作流规范" tabindex="-1">1.3 发布工作流规范 <a class="header-anchor" href="#_1-3-发布工作流规范" aria-hidden="true">#</a></h3><p>发布工作流指的是将‘软件成品’对外发布 (如测试或生产) 的一套流程, 将这套流程规范化后，可以实现自动化.</p><p>举个例子, 一个典型的发布工作流如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyRICLMFxuJAnsXc8JQJmNWiazSOA1KjiajHP1SZlh59gLibPZ1iaJwufrOA/640?wx_fmt=png" alt=""></p><ul><li><p>代码变更</p></li><li><p>提交代码变更到远程版本库</p></li><li><p>程序通过 CI 测试 (例如 Travis 变绿)</p></li><li><p>提升 package.json 中的版本</p></li><li><p>生成 CHANGELOG</p></li><li><p>提交 package.json 和 <a href="http://CHANGELOG.md" target="_blank" rel="noreferrer">CHANGELOG.md</a> 文件</p></li><li><p>打上 Tag</p></li><li><p>推送</p></li></ul><p>如果你遵循上面的规范，那么就可以利用社区上现有的工具来自动化这个流程. 这些工具有:</p><ul><li><p>conventional-changelog-cli</p></li><li><p>conventional-github-releaser</p></li><li><p>实际上自己开发一个也不是特别难的事情.</p></li></ul><h3 id="_1-4-持续集成" tabindex="-1">1.4 持续集成 <a class="header-anchor" href="#_1-4-持续集成" aria-hidden="true">#</a></h3><p>将整套开发工作流确定下来之后, 就可以使用<code>持续集成服务</code>来自动化执行整个流程。比如一个典型的 CI 流程:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzybXDmN1Emg7KyysMtA7S1ibjibWsEZIDZodg9h8sfUpGxEBx07QcZMnXA/640?wx_fmt=png" alt=""></p><p><strong>持续集成是什么，有什么意义呢</strong>?</p><p>我们需要<code>持续集成</code>拆成两个词分别来理解, 什么是<code>持续</code>? 什么是<code>集成</code>?</p><p><strong>持续 (Continuous), 可以理解为&#39;频繁&#39;或者‘连续性’</strong>. 不管是持续集成还是敏捷开发思维、看板，都认为‘持续’是它们的基础。</p><p>举一个通俗的例子，<strong>比如代码检查，‘持续的’的代码检查就是代码一变动 (如保存，或者 IDE 实时检查、或者提交到版本库时) 就马上检查代码，而‘非持续’的代码检查就是在完成所有编码后，再进行检查</strong>。对比两者可以发现，持续性的代码检查可以尽早地发现错误，而且错误也比较容易理解和处理，反之非持续性的代码检查，可能会发现一堆的错误，失之毫厘谬以千里，错误相互牵连，最终会变得难以收拾。</p><p><strong>‘持续’的概念，可以用于软件开发的方方面面，本质上就是把传统瀑布式的软件开发流程打碎，形成一个个更小的开发闭环，持续地输出产品，同时产品也持续地给上游反馈和纠正</strong>。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyjgphOkwf3JGc9PZ25yORULYxmNX238GljY0icAFjkRYytUmNx7D0VNA/640?wx_fmt=png" alt=""></p><p><strong>那什么是‘集成’呢</strong>？狭义的集成可以简单认为是‘集成测试’吧. 集成测试可以对代码静态测试、单元测试、通过单元测试后可以进行集成测试，在应用组成一个整体后在模拟环境中跑 E2E 测试等等。也就是说，在这里进行一系列的自动化测试来验证软件系统。</p><p>广义的持续集成服务，不仅仅是测试，它还衍生出很多概念，例如持续交付、持续部署，如下图</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyg3yeJxj6xOIXTuHs1KjEk303nIpvVxCRcz2NYkqpl1BbFPPuqdmokQ/640?wx_fmt=png" alt=""></p><p>OK, <strong>总结一下为什么持续集成的好处</strong>:</p><ul><li><p>尽早发现错误，快速试错。越早发现错误，处理错误的成本越低</p></li><li><p>自动化工作流，减少人工干预。人类比机器容易犯错, 而且机器擅长做重复的事情</p></li></ul><p><strong>对于持续集成规范一般会定义这些内容</strong>:</p><ul><li><p>执行的环境. 比如容器、Node 版本、操作系统等等</p></li><li><p>触发的条件。比如定时触发、在哪个分支触发、会触发什么任务等等</p></li><li><p>执行的任务</p></li><li><p>划分持续集成的阶段. 比如</p></li><li><p>检查：包括单元测试和代码 lint. 所有 push 到版本库的代码都会跑这个阶段. 一般可以在提交 title 中包含 [ci skip] 来跳过这个阶段</p></li><li><p>构建: 对前端项目进行构建. 只有打上版本 tag 的提交或 release 分支会跑构建任务</p></li><li><p>发布: 将前端的构建结果进行交付 / 发布. 只有打上版本 tag 的提交或者 release 分支在构建成功后会跑发布任务</p></li><li><p>定义持续集成脚本模板</p></li></ul><p>常用的 CI 服务:</p><ul><li><p>Github</p></li><li><p>Travis CI</p></li><li><p>CircleCI</p></li><li><p>完整列表</p></li><li><p>GitLab: Gitlab-CI</p></li><li><p>通用</p></li><li><p>Jenkins</p></li></ul><p>扩展</p><ul><li>持续集成是什么</li></ul><h3 id="_1-5-任务管理" tabindex="-1">1.5 任务管理 <a class="header-anchor" href="#_1-5-任务管理" aria-hidden="true">#</a></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzy4FbJiadMreEs5dcQWziaVrcEtQsibY1ickoyian13aKwbjAXcDBDNjMfIZA/640?wx_fmt=png" alt=""></p><p>作为前端 Leader 少不了任务管理。<strong>看板是目前最为流行的任务管理工具，它可以帮助我们了解项目的进度、资源的分配情况、还原开发现场</strong>.</p><p>笔者毕业第一年在一家很小的外包公司中工作，初生牛犊不怕虎，我竟然给老板推销起了看板和敏捷项目管理，想要改善项目管理这块效率低下问题，老板表示很支持，但是其他成员积极性并不高, 结果当然是失败的。</p><p>当时还起草了一份‘看板实施细则’, 所以任务管理这一块也算小有心得吧.</p><p>说说一些比较好用的工具吧：</p><ul><li><p><strong>基于 issue 看板</strong> - 可以基于 Gitlab 或 Github 的 Issue 来做任务管理，它们都支持看板。很 Geek，推荐</p></li><li><p><strong>Tower</strong> - 专门做看板任务管理的。小团队基本够用。我们现在就使用这款产品</p></li><li><p><strong>teambition</strong> - 和 Tower 差不多，没有深入使用过</p></li><li><p><strong>Trello</strong> - 颜值高.</p></li></ul><h2 id="_2-技术栈规范" tabindex="-1">2 技术栈规范 <a class="header-anchor" href="#_2-技术栈规范" aria-hidden="true">#</a></h2><p>笔者现在所在的公司之前前端技术栈就非常混乱，Vue、React 和 AngularJS 三大框架都有, 而且风格相差也很大. 当时我就想收包裹走人. 关于技术栈不规范的下场可以参考印度的飞机: &lt;为什么印度的飞机频繁被摔？&gt;</p><p>很少有人能精通这三个框架的，更别说是一个团队。</p><p><strong>三大框架跟编程语言一样都有自己的设计哲学，这跟库是不一样, 一个库的替换成本很低；而框架的背后是一个架构、一个生态。每个框架背后牵涉着开发思维、生态系统、配套工具、最佳实践、性能调优。要精通和熟练一个框架需要付出的成本是很高</strong>。</p><p><strong>所以说团队的开发效率是基于稳定且熟练的技术栈的</strong>。稳定的技术栈规范有利于团队协作和沟通; 另外如果团队精通这个技术栈，当出现问题或者需要深入调优, 会相对轻松。</p><p>前端技术栈规范主要包含下面这些类型:</p><ul><li><p>编程语言 - Typescript 或 Javascript</p></li><li><p>UI 框架及其配套生态, 以及备选方案。其背后的生态非常庞大:</p></li><li><p>UI 框架</p></li><li><p>路由</p></li><li><p>状态管理</p></li><li><p>组件库</p></li><li><p>国际化</p></li><li><p>动画</p></li><li><p>服务端渲染</p></li><li><p>脚手架、CLI 工具</p></li><li><p>组件测试</p></li><li><p>样式. 包含了命名规范、预处理器、方法论等等</p></li><li><p>动画引擎</p></li><li><p>QA. 包含了测试、Lint、格式化工具、监控</p></li><li><p>项目构建工具流. 例如 webpack、vue-cli</p></li><li><p>包管理器。npm、yarn</p></li><li><p>项目管理工具</p></li><li><p>时间处理。例如 Moment.js</p></li><li><p>模板引擎</p></li><li><p>开发工具</p></li><li><p>后端开发框架</p></li><li><p>工具库</p></li><li><p>开发 / 调试工具</p></li><li><p>等等</p></li></ul><h3 id="_2-1-技术选型" tabindex="-1">2.1 技术选型 <a class="header-anchor" href="#_2-1-技术选型" aria-hidden="true">#</a></h3><p><strong>如何从零对团队的技术栈进行规范, 或者说怎么进行选型呢</strong>？举个例子, 先确定备选项, 你现在要选 Vue 还是选 React(一个可能引起论战的主题)？</p><p>恰好前几天在 SegmentFault 回答了一个问题: &lt;什么时候用 vue 什么时候用 react？&gt;, 我讲了一个我们<strong>几年前</strong>是如何决定要使用 React 还是 Vue 的例子 (注意结果不重要！)：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyl0n0NKC9gpnQD3hm2VTs9eIrLO0aiaFDdXUIcXlVGO0icvsCQhCYafPA/640?wx_fmt=png" alt=""></p><p>&lt;谈谈技术选型的注意事项&gt; 这篇文章写得非常好，给了我一些启发。结合上面的回答的例子, 来讲一讲在对相关技术进行选型的一些方法 (评分项):</p><ul><li><p><strong>选择你最熟悉的技术</strong>。上面说到团队如果熟悉该技术，则可以很好地控制使用过程中的风险，方便对程序进行调优。所以成员熟悉、或至少 Leader 熟悉程度，是技术选型的一个打分项。 我们团队最终选择 React 的一个原因，就是我们熟悉它，它已经在现有的几个应用中良好的运行了，所以 React + 1</p></li><li><p><strong>选择拥有强大生态和社区支撑的开源技术</strong>。有强大的生态和社区意味着，很多东西你不需要重复去造轮子，或者遇到问题可以很快解决，有更多的选择。从公司层面、使用活跃的技术也比较好招人。 上面的例子也提到了这点，几年前 React 的生态是强于 Vue 的，所以 React + 1</p></li><li><p><strong>选择成长期的技术</strong>。&lt;谈谈技术选型的注意事项&gt; 里面有一句话：&#39;选择一个技术的最低标准是，技术的生命周期必须显著长于项目的生命周期&#39; 我们选择的技术应该是向前发展的、面向未来的, 这是选型的基本原则。所以我们一般不会去选择那些&#39;过气&#39;的技术，比如<code>AngularJS</code>(1.x)、<code>Backbone</code>. 因为现在有更好的选择，不必过于保守。 ‘向前’还意味着 Leader 要能够预判该技术未来走向，这里有很多参考因素，比如大厂的支撑、目前社区的活跃度、开发活跃度等等 React、Vue 都非常有动力，比如 React 最近的 React Hook、还有未来的 ConcurrentMode、Async Rendering... 在这点上 Vue 和 React 打成平手吧</p></li><li><p><strong>API 的稳定性</strong>。比较典型的例子就是 Angular 和 Python，API 不稳定会导致社区的割裂，也会导致项目升级成本变高、或者无法升级, 最终成为技术债。 不过值得庆幸的是因为有这么多历史教训，现在开源项目在 API 变更上面是非常谨慎的，参考 [译] Vue 最黑暗的一天事件. 这点上 React 和 Vue 依旧打平</p></li><li><p><strong>基础设施配合</strong>。一个技术往往不是孤立存在的，它需要和其他技术相互配合，这种技术之间的融合度也是需要考虑的。 这个根据团队使用情况来定，比如我们团队统一使用 Typescript，Vue 跟 Typescript 配合使用其实不理想，所以 React + 1</p></li><li><p><strong>业务考虑</strong> &lt;谈谈技术选型的注意事项&gt; 提到一点就是‘学会从业务端开始思考’. 意思<strong>就是选型需要充分地理解业务，理解用户需求，当下需要解决的首要问题，以及可能的风险有哪些，再将目标进行分解，进行具体的技术选型、模型设计、架构设计</strong>. 一个典型的例子就是 10 年前火遍世界的<code>Rails</code>, 后端是使用 Rails 还是 Java/C#/PHP 这些传统后端技术? 很多初创公司 (如 Github、Gitlab、Twitter) 选择了前者，他们需要快速开发原型、快速占领市场, Rails 开发很爽很快啊, 这种选型就是符合‘业务需求的’。 那么前端好像跟业务离得有点远? 随着‘大前端’的发展，我们的工作对公司业务的影响只会越来越大。 比如上面提到的 React Native，我们当时有考虑在移动端应用 React Native 技术，实现客户端的跨平台，这就是业务影响啊。这时候 React 是不是又要 +1? 同理还有什么服务端渲染、Serverless 等等，期待前端的地位会越来越高</p></li></ul><p>综上，在这个案例中，React 是胜出的。</p><p>扩展:</p><ul><li><p>谈谈技术选型</p></li><li><p>谈谈技术选型的注意事项</p></li></ul><h3 id="_2-2-迎接新技术" tabindex="-1">2.2 迎接新技术 <a class="header-anchor" href="#_2-2-迎接新技术" aria-hidden="true">#</a></h3><p>当然，对于团队而言也要鼓励学习新的技术、淘汰旧的技术栈。因为一般而言新的技术或解决方案，是为了更高的生产力而诞生的。<strong>当团队容纳一个新的技术选型需要考虑以下几点</strong>：</p><ul><li><p><strong>学习成本</strong>。考虑团队成员的接纳能力。如果成本小于收获的利益，在团队里面推行估计阻力会比较大</p></li><li><p><strong>收益</strong>。是否能够解决当前的某些痛点</p></li><li><p><strong>考虑风险</strong>。一般我们不能将一个实验阶段的技术使用的生产环境中</p></li></ul><p>就我们团队而言，每个成员都有自己感兴趣的方向和领域，所以我们可以分工合作，探索各自的领域，再将成果分享出来，如果靠谱的话则可以在实验项目中先试验一下，最后才推广到其他项目.</p><h2 id="_3-浏览器兼容规范" tabindex="-1">3 浏览器兼容规范 <a class="header-anchor" href="#_3-浏览器兼容规范" aria-hidden="true">#</a></h2><p>前端团队应该根据针对应用所面对的用户情况、应用类型、开发成本、浏览器市场统计数据等因素，来制定自己的浏览器兼容规范，并写入应用使用手册中.</p><p><strong>有了浏览器兼容规范，前端开发和兼容性测试就有理有据，避免争议; 同时它也是前端团队的一种对外声明，除非特殊要求，不符合浏览器兼容规范的浏览器，前端开发人员可以选择忽略</strong>。</p><h3 id="_3-1-确定兼容策略" tabindex="-1">3.1 确定兼容策略 <a class="header-anchor" href="#_3-1-确定兼容策略" aria-hidden="true">#</a></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyd6Y3rKHRQJsYOl0bOueYcTClCGb4zkSqHianicj3JxibAeC6m1Upd4yWg/640?wx_fmt=jpeg" alt=""></p><p><strong>渐进增强</strong>还是<strong>优雅降级</strong>. 这是两个不同方向策略，<strong>渐进增强保证低版本浏览器的体验，对于支持新特性的新浏览器提供稍好的体验</strong>；<strong>优雅降级则是相反的，为现代浏览器提供最好的体验，而旧浏览器则退而求之次，保证大概的功能</strong>.</p><p>选择不同的策略对前端开发的影响是比较大的，但是开发者没有选择权。<strong>确定哪种兼容策略，应该取决于用户比重，如果大部分用户使用的是现代浏览器，就应该使用优雅降级，反之选择渐进增强</strong>.</p><h3 id="_3-2-确定浏览器分级" tabindex="-1">3.2 确定浏览器分级 <a class="header-anchor" href="#_3-2-确定浏览器分级" aria-hidden="true">#</a></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyH1WPGAuBd31EKm4CHibqW3eEh3TGFlYQ9IKOMPS02A4nloGmRHfTribA/640?wx_fmt=gif" alt=""></p><p>YUI 就曾提出浏览器分级原则，到今天这个原则依然适用。简单说就是将浏览器划分为多个等级，不同等级表示不同的支持程度. 比如我们团队就将浏览器划分为以下三个等级:</p><ul><li><p><strong>完全兼容</strong>: 保证百分百功能正常</p></li><li><p><strong>部分兼容</strong>: 只能保证功能、样式与需求大致一致。对于一些不影响主体需求和功能的 bug，会做降低优先级处理或者不处理。</p></li><li><p><strong>不兼容</strong>: 不考虑兼容性</p></li></ul><p>一般而言, 根据浏览器市场分布情况、用户占比、开发成本等因素划分等级.</p><p>举个例子，下面是我们对管理系统的兼容规范:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyn2YBPBZITnfia6qNcxbk214kGOiaLx2TnJjxjtU06ZlFpse9mgfXsTNQ/640?wx_fmt=png" alt=""></p><h3 id="_3-3-获取统计数据" tabindex="-1">3.3 获取统计数据 <a class="header-anchor" href="#_3-3-获取统计数据" aria-hidden="true">#</a></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyfapj1nbmvqbXDy0svJANhjsTExQOgWWVEWibgjUNt8LTiaTNtcYtpichg/640?wx_fmt=png" alt=""></p><p>百度统计是中文网站使用最为广泛的、免费的流量分析平台. 如上图，通过这些统计平台可以获取到终端真实的浏览器使用情况, 点击查看示例。</p><p>如果公司没有开发自己监控服务，还是建议使用这些免费的，有大厂支持的监控工具:</p><ul><li><p>百度统计</p></li><li><p>友盟</p></li><li><p>Google Analytics 需要 kx 上网</p></li></ul><p><strong>可以从这些地方获取通用的浏览器统计数据</strong>:</p><ul><li><p>百度流量研究院：主要提供国内浏览器统计</p></li><li><p>statcounter: 国际浏览器统计</p></li><li><p>浏览器发布年份统计</p></li></ul><p><strong>确定浏览器是否支持某个特性</strong>:</p><ul><li><p>caniuse</p></li><li><p>MDN</p></li></ul><h2 id="_4-项目组织规范" tabindex="-1">4 项目组织规范 <a class="header-anchor" href="#_4-项目组织规范" aria-hidden="true">#</a></h2><p>项目组织规范定义了如何组织一个前端项目, 例如项目的命名、项目的文件结构、版本号规范等等。尤其对于开源项目，规范化的项目组织就更重要了。</p><h3 id="_4-1-通用的项目组织规范" tabindex="-1">4.1 通用的项目组织规范 <a class="header-anchor" href="#_4-1-通用的项目组织规范" aria-hidden="true">#</a></h3><p>一个典型的项目组织规范如下:</p><ul><li><p><strong><a href="http://README.md" target="_blank" rel="noreferrer">README.md</a></strong>: 项目说明, 这个是最重要。你必须在这里提供关于项目的关键信息或者相关信息的入口. 一般包含下列信息:</p></li><li><p>简要描述、项目主要特性</p></li><li><p>运行环境 / 依赖、安装和构建、测试指南</p></li><li><p>简单示例代码</p></li><li><p>文档或文档入口, 其他版本或相关资源入口</p></li><li><p>联系方式、讨论群</p></li><li><p>许可、贡献 / 开发指南</p></li><li><p><strong><a href="http://CHANGELOG.md" target="_blank" rel="noreferrer">CHANGELOG.md</a></strong>: 放置每个版本的变动内容, 通常要描述每个版本变更的内容。方便使用者确定应该使用哪个版本. 关于 CHANGELOG 的规范可以参考 keep a changelog</p></li><li><p><strong>package.json</strong>: 前端项目必须. 描述当前的版本、<strong>可用的命令</strong>、包名、依赖、环境约束、项目配置等信息.</p></li><li><p><strong>.gitignore</strong>: 忽略不必要的文件，避免将自动生成的文件提交到版本库</p></li><li><p><strong>.gitattributes</strong>: git 配置，有一些跨平台差异的行为可能需要在这里配置一下，如换行规则</p></li><li><p><strong>docs/</strong>: 项目的细化文档, 可选.</p></li><li><p><strong>examples/</strong>: 项目的示例代码，可选.</p></li><li><p><strong>build</strong>: 项目工具类脚本放置在这里，非必须。如果使用统一构建工具，则没有这个目录</p></li><li><p><strong>dist/</strong>: 项目构建结果输出目录</p></li><li><p><strong>src/</strong>: 源代码目录</p></li><li><p>*<strong>*tests/</strong>: 单元测试目录. 按照 Jest 规范, <code>__tests__</code>目录通常和被测试的模块在同一个父目录下, 例如:</p></li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">/src  </span></span>
<span class="line"><span style="color:#A6ACCD;">  __tests__/  </span></span>
<span class="line"><span style="color:#A6ACCD;">    index.ts  </span></span>
<span class="line"><span style="color:#A6ACCD;">    a.ts  </span></span>
<span class="line"><span style="color:#A6ACCD;">  index.ts  </span></span>
<span class="line"><span style="color:#A6ACCD;">  a.ts  </span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li><p><strong>tests</strong>: 全局的测试目录，通常放应用的集成测试或 E2E 测试等用例</p></li><li><p><strong>.env*</strong>: 项目中我们通常会使用<code>环境变量</code>来影响应用在不同运行环境下的行为. 可以通过 dotEnv 来从文件中读取环境变量. 通常有三个文件:</p></li><li><p><code>.env</code> 通用的环境变量</p></li><li><p><code>.env.development</code> 开发环境的环境变量</p></li><li><p><code>.env.production</code> 生成环境的环境变量 基本上这些文件的变动的频率很少，团队成员应该不要随意变动，以免影响其他成员。所以通常会使用<code>.env.*.local</code>文件来覆盖上述的配置, 另外会设置版本库来忽略<code>*.local</code>文件.</p></li></ul><p><strong>对于开源项目通常还包括这些目录</strong>:</p><ul><li><p><strong>LICENSE</strong>: 说明项目许可</p></li><li><p><strong>.github</strong>: 开源贡献规范和指南</p></li><li><p>CONTRIBUTING: 贡献指南, 这里一般会说明贡献的规范、以及项目的基本组织、架构等信息</p></li><li><p>CODE_OF_CONDUCT: 行为准则</p></li><li><p>COMMIT_CONVENTION: 提交信息规范，上文已经提及</p></li><li><p>ISSUE_TEMPLATE: Issue 的模板，github 可以自动识别这个模板</p></li><li><p>PULL_REQUEST_TEMPLATE: PR 模板</p></li></ul><p>任意一个优秀的开源项目都是你的老师，例如 React、Vue...</p><h3 id="_4-2-目录组织的风格" tabindex="-1">4.2 目录组织的风格 <a class="header-anchor" href="#_4-2-目录组织的风格" aria-hidden="true">#</a></h3><p>上面只是一个通用的项目组织规范，具体源代码如何组织还取决于你们使用的技术栈和团队喜好。网上有很多教程，具体可以搜索<code>怎么组织XX项目</code>. 总结一下项目组织主要有三种风格:</p><ul><li><strong>Rails-style</strong>: 按照文件的类型划分为不同的目录，例如<code>components</code>、<code>constants</code>、 <code>typings</code>、<code>views</code>. 这个来源于 Ruby-on-Rails 框架，它按照 MVC 架构来划分不同的目录类型，典型的目录结构如下:</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">  app  </span></span>
<span class="line"><span style="color:#A6ACCD;">    models # 模型  </span></span>
<span class="line"><span style="color:#A6ACCD;">    views # 视图  </span></span>
<span class="line"><span style="color:#A6ACCD;">    controllers # 控制器  </span></span>
<span class="line"><span style="color:#A6ACCD;">    helpers # 帮助程序  </span></span>
<span class="line"><span style="color:#A6ACCD;">    assets  # 静态资源  </span></span>
<span class="line"><span style="color:#A6ACCD;">  config     # 配置  </span></span>
<span class="line"><span style="color:#A6ACCD;">    application.rb  </span></span>
<span class="line"><span style="color:#A6ACCD;">    database.yml  </span></span>
<span class="line"><span style="color:#A6ACCD;">    routes.rb      # 路由控制  </span></span>
<span class="line"><span style="color:#A6ACCD;">    locales        # 国际化配置  </span></span>
<span class="line"><span style="color:#A6ACCD;">    environments/  </span></span>
<span class="line"><span style="color:#A6ACCD;">  db        # 数据库相关  </span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li><strong>Domain-style</strong>: 按照一个功能特性或业务创建单独的目录，这个目录就近包含多种类型的文件或目录. 比如一个典型的 Redux 项目，所有项目的文件就近放置在同一个目录下:</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Users/  </span></span>
<span class="line"><span style="color:#A6ACCD;">Home/  </span></span>
<span class="line"><span style="color:#A6ACCD;">  components/  </span></span>
<span class="line"><span style="color:#A6ACCD;">  actions.js  </span></span>
<span class="line"><span style="color:#A6ACCD;">  actionTypes.js  </span></span>
<span class="line"><span style="color:#A6ACCD;">  constants.js  </span></span>
<span class="line"><span style="color:#A6ACCD;">  index.js  </span></span>
<span class="line"><span style="color:#A6ACCD;">  model.js  </span></span>
<span class="line"><span style="color:#A6ACCD;">  reducer.js  </span></span>
<span class="line"><span style="color:#A6ACCD;">  selectors.js  </span></span>
<span class="line"><span style="color:#A6ACCD;">  style.css  </span></span>
<span class="line"><span style="color:#A6ACCD;">index.js  </span></span>
<span class="line"><span style="color:#A6ACCD;">rootReducer.js  </span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><ul><li><strong>Ducks-style</strong>: 优点类似于 Domain-style，不过更彻底, 它通常将相关联的元素定义在一个文件下。Vue 的单文件组件就是一个典型的例子，除此之外 Vuex 也是使用这种风格:</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">&lt;template&gt;  </span></span>
<span class="line"><span style="color:#A6ACCD;">  &lt;div id=&quot;app&quot;&gt;  </span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;h1&gt;My Todo App!&lt;/h1&gt;  </span></span>
<span class="line"><span style="color:#A6ACCD;">    &lt;TodoList/&gt;  </span></span>
<span class="line"><span style="color:#A6ACCD;">  &lt;/div&gt;  </span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/template&gt;  </span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;script&gt;  </span></span>
<span class="line"><span style="color:#A6ACCD;">import TodoList from &#39;./components/TodoList.vue&#39;  </span></span>
<span class="line"><span style="color:#A6ACCD;">export default {  </span></span>
<span class="line"><span style="color:#A6ACCD;">  components: {  </span></span>
<span class="line"><span style="color:#A6ACCD;">    TodoList  </span></span>
<span class="line"><span style="color:#A6ACCD;">  }  </span></span>
<span class="line"><span style="color:#A6ACCD;">}  </span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/script&gt;  </span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;style lang=&quot;scss&quot;&gt;  </span></span>
<span class="line"><span style="color:#A6ACCD;">@import &#39;./variables.scss&#39;;  </span></span>
<span class="line"><span style="color:#A6ACCD;">/* ... */  </span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/style&gt;  </span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>大部分情况下, 我们都是使用混合两种方式的目录结构，例如:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">src/</span></span>
<span class="line"><span style="color:#A6ACCD;">  components/      # 🔴 项目通用的‘展示组件’</span></span>
<span class="line"><span style="color:#A6ACCD;">    Button/</span></span>
<span class="line"><span style="color:#A6ACCD;">      index.tsx    # 组件的入口, 导出组件</span></span>
<span class="line"><span style="color:#A6ACCD;">      Groups.tsx   # 子组件</span></span>
<span class="line"><span style="color:#A6ACCD;">      loading.svg  # 静态资源</span></span>
<span class="line"><span style="color:#A6ACCD;">      style.css    # 组件样式</span></span>
<span class="line"><span style="color:#A6ACCD;">    ...</span></span>
<span class="line"><span style="color:#A6ACCD;">    index.ts       # 到处所有组件</span></span>
<span class="line"><span style="color:#A6ACCD;">  containers/      # 🔴 包含&#39;容器组件&#39;和&#39;页面组件&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">    LoginPage/     # 页面组件, 例如登录</span></span>
<span class="line"><span style="color:#A6ACCD;">      components/  # 页面级别展示组件，这些组件不能复用与其他页面组件。</span></span>
<span class="line"><span style="color:#A6ACCD;">        Button.tsx # 组件未必是一个目录形式，对于一个简单组件可以是一个单文件形式. 但还是推荐使用目录，方便扩展</span></span>
<span class="line"><span style="color:#A6ACCD;">        Panel.tsx</span></span>
<span class="line"><span style="color:#A6ACCD;">      reducer.ts   # redux reduces</span></span>
<span class="line"><span style="color:#A6ACCD;">      useLogin.ts  # (可选)放置&#39;逻辑&#39;, 按照👆分离逻辑和视图的原则，将逻辑、状态处理抽取到hook文件</span></span>
<span class="line"><span style="color:#A6ACCD;">      types.ts     # typescript 类型声明</span></span>
<span class="line"><span style="color:#A6ACCD;">      style.css</span></span>
<span class="line"><span style="color:#A6ACCD;">      logo.png</span></span>
<span class="line"><span style="color:#A6ACCD;">      message.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">      constants.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">      index.tsx</span></span>
<span class="line"><span style="color:#A6ACCD;">    HomePage/</span></span>
<span class="line"><span style="color:#A6ACCD;">    ...</span></span>
<span class="line"><span style="color:#A6ACCD;">    index.tsx      # 🔴应用根组件</span></span>
<span class="line"><span style="color:#A6ACCD;">  hooks/           # 🔴可复用的hook</span></span>
<span class="line"><span style="color:#A6ACCD;">    useList.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">    usePromise.ts</span></span>
<span class="line"><span style="color:#A6ACCD;">  ...</span></span>
<span class="line"><span style="color:#A6ACCD;">  index.tsx        # 应用入口, 在这里使用ReactDOM对跟组件进行渲染</span></span>
<span class="line"><span style="color:#A6ACCD;">  stores.ts        # redux stores</span></span>
<span class="line"><span style="color:#A6ACCD;">  contants.ts      # 全局常量</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>框架官方很少会去干预项目的组织方式，读者可以参考下面这些资源来建立自己项目组织规范:</p><ul><li><p>Redux 常见问题：代码结构</p></li><li><p>react-boilerplate</p></li><li><p>vuex 项目结构</p></li><li><p>React 组件设计实践总结 02 - 组件的组织</p></li></ul><h3 id="_4-3-脚手架和项目模板" tabindex="-1">4.3 脚手架和项目模板 <a class="header-anchor" href="#_4-3-脚手架和项目模板" aria-hidden="true">#</a></h3><p>在将项目结构规范确定下来后，可以创建自己的脚手架工具或者项目模板，用于快速初始化一个项目或代码模板。</p><p>相关资源:</p><ul><li><p>yeoman - 老牌的项目脚手架工具</p></li><li><p>plop - 代码生成辅助 CLI</p></li><li><p>hygen - 类似于 plop</p></li><li><p>generact - 生成 React 组件, 大部分组件的文件结构差不多, 这个工具就是帮助你生成这些重复的代码</p></li><li><p>babel-code-generator - 利用 babel 来实现更高级的代码编辑和自动生成</p></li></ul><h2 id="_5-编码规范" tabindex="-1">5 编码规范 <a class="header-anchor" href="#_5-编码规范" aria-hidden="true">#</a></h2><p>网络上大部分‘前端规范’指的都是编码规范, 这是一种‘狭义’的前端规范.</p><p><strong>统一的编码规范对团队项目的长远维护不无裨益. 一致性的代码规范可以增强团队开发协作效率、提高代码质量、减少遗留系统维护的负担</strong>。</p><p>最直接的好处就是避免写出糟糕的代码, 糟糕的代码与新手和老手关系不大，我也见过好处工作很多年的‘资深’工程师写出恶心的代码. 这样的代码随着项目的迭代会变得难以控制。</p><p><strong>现代的 Lint 工具已经非常先进，几乎可以约束各种编码行为</strong>. 比如约束一个文件的长度、函数的复杂度、命名规范、注释规范、接口黑名单、DeadCode、检查简单的逻辑错误...</p><p>每一个程序员心目中对‘好代码’都有自己的主见，统一的编码规范可以像秦始皇统一战国一样，避免不必要的论战和争议。</p><p><strong>其实与其自己建立前端编码规范，笔者推荐选择社区沉淀下来的规范</strong>. 这方面的资源非常多，所以本文也不武断地提出自己的规范建议. 推荐下面这些资源:</p><h3 id="_5-1-javascript" tabindex="-1">5.1 Javascript <a class="header-anchor" href="#_5-1-javascript" aria-hidden="true">#</a></h3><ul><li><p>Lint 工具</p></li><li><p>ESLint - 🔥 目前是社区最流行的、通用的 Javascript Lint 工具，Lint 界的 Babel。支持定制插件、preset。如果不想折腾可以选择它的一些预定义配置</p></li><li><p>TSLint - Typescript Lint 工具。不过即将废弃了, 推荐使用 ESLint</p></li><li><p>规范</p></li><li><p>JavaScript Standard Style - 🔥 零配置的、‘标准’的 Javascript 编码规范. 底层基于 Eslint。目前不支持 Typescript</p></li><li><p>Airbnb JavaScript Style Guide - Airbnb 的编码规范，业界标杆</p></li><li><p>类型检查. 暂时将它们归类到这里，因为它们同属于‘静态测试’</p></li><li><p>Typescript - 🔥 Javascript 语言的超集，这是一门‘新’的语言，而不是简单的类型检查器. 不过<strong>它也支持原生 Javascript 的类型检查</strong></p></li><li><p>Flow - Facebook 出品的类型检查器，语法和 Typescript 类似. 个人推荐使用 Typescript</p></li></ul><h3 id="_5-2-html" tabindex="-1">5.2 HTML <a class="header-anchor" href="#_5-2-html" aria-hidden="true">#</a></h3><ul><li><p>Lint 工具</p></li><li><p>HTMLHint</p></li><li><p>bootlint</p></li><li><p>规范</p></li><li><p>Code Guide</p></li></ul><h3 id="_5-3-css" tabindex="-1">5.3 CSS <a class="header-anchor" href="#_5-3-css" aria-hidden="true">#</a></h3><ul><li><p>Lint 工具</p></li><li><p>stylelint - 🔥 通用的 CSS 编码检查工具，支持最新的 CSS 语法、CSS-in-js、以及其他类 CSS 语法 (如 SCSS、Less). 它也有预定义配置，推荐使用</p></li><li><p>规范</p></li><li><p>Airbnb CSS / Sass Styleguide</p></li><li><p>Code Guide</p></li><li><p>更多</p></li><li><p>方法论</p></li><li><p>BEM - 🔥 BEM 命名规范</p></li><li><p>OOCSS</p></li><li><p>smacss</p></li></ul><p>关于 CSS 可以学习 Bootstrap 这些传统 UI 框架，他们的代码组织性非常好, 值得学习</p><h3 id="_5-4-代码格式化" tabindex="-1">5.4 代码格式化 <a class="header-anchor" href="#_5-4-代码格式化" aria-hidden="true">#</a></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyXfhxEEBYbiaNQm2bMbeJFiaIzPBTwhdxZEsucJCjQcXVM0HYls8iapyhg/640?wx_fmt=png" alt=""></p><ul><li>Prettier - 🔥 关于代码格式化的所有东西都交给它吧！</li></ul><p>基本上，所有代码格式相关的工作都可以交给 Prettier 来做，在这个基础上再使用 Eslint 覆盖语义相关的检查</p><h3 id="_5-5-集大成的" tabindex="-1">5.5 集大成的 <a class="header-anchor" href="#_5-5-集大成的" aria-hidden="true">#</a></h3><ul><li><p>isobar 前端代码规范及最佳实践</p></li><li><p>凹凸实验室代码规范</p></li><li><p>百度 FEX 规范</p></li><li><p>老牌的 NEC 规范 - 有点老</p></li></ul><h3 id="_5-6-特定框架风格指南" tabindex="-1">5.6 特定框架风格指南 <a class="header-anchor" href="#_5-6-特定框架风格指南" aria-hidden="true">#</a></h3><ul><li><p>vue-style-guide</p></li><li><p>Airbnb React/JSX Style Guide</p></li><li><p>React 组件设计实践总结 - 自荐一下笔者写的 React 组件设计相关实践</p></li></ul><h3 id="_5-7-code-review" tabindex="-1">5.7 Code Review <a class="header-anchor" href="#_5-7-code-review" aria-hidden="true">#</a></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzygRFgQIIK7Y0TqdCsvB1DlicTqnqict0UXrTSib9ZQKdsmicfPMD2Jrmmpw/640?wx_fmt=png" alt=""></p><p>上述的 Lint 工具和类型检查器, 可以约束代码风格、避免低级的语法错误。但是即使通过上面的 Lint 和类型检查，代码也可能未必是‘好代码’。</p><p><strong>很多代码设计的‘最佳实践’是无法通过具象化的自动化工具或文档覆盖的, 这时候，&#39;经验&#39;或者&#39;群体智慧&#39;就派上用场了</strong>. 比如 Code Review 阶段会检查这些东西:</p><ul><li><p>编程原则、设计思想. 例如符合 SOLID 原则? 是否足够 DRY？接口设计是否简洁易扩展、</p></li><li><p>模块耦合程度、代码重复</p></li><li><p>代码健壮性。是否存在内存泄露、是否线程安全、是否有潜在性能问题和异常、错误是否被处理</p></li><li><p>代码的性能和效率。</p></li><li><p>是否有没有考虑到的场景？</p></li></ul><p>如果你们是第一次推行 Code Review, 可以建立一个检查列表，对照着进行检查。熟练后，心中自然无码。</p><p>Code Review 有很多好处，比如：</p><ul><li><p><strong>Code Review 可以让其他成员都熟悉代码</strong>。这样保证其他人都可以较快地接手你的工作，或者帮你解决某些问题</p></li><li><p><strong>提高代码质量</strong>。毫无疑问. 一方面是<em>主动性</em>的代码质量提升，比如你的代码需要被人 Review，会自觉尽量的提高代码质量；另一方面，其他成员可以检查提交方的代码质量</p></li><li><p><strong>检查或提高新成员的编程水平</strong>。培养新人时，由于不信任它们提交的代码，我们会做一次 Review 检查代码是否过关。另一方面这是一次真实的案例讲解, 可以较快提高他们的能力</p></li></ul><p><strong>Code Review 有两种方式: 一个<code>提交时</code>、一个是<code>定时</code></strong>:</p><ul><li><p><code>提交时</code>. 大部分开源项目采用这种方式。通俗讲就是 Pull Request。只有代码通过测试、和其他成员的 Review 才可以合进正式版本库。这种方式也称为‘阻塞式’代码检查，一般配合 GitFlow 使用。</p></li><li><p><code>定时</code>. 在项目完结后、项目的某个里程碑、或者固定的时间 (每天、每个星期..). 团队成员聚在一起，回顾自己写的代码, 让其他成员进行审查</p></li></ul><p>Code Review 是比较难以推行的，不过这个也要看你们团队的情况，向我们钱少活多的团队，很少的时间去立马去兼顾其他成员的代码. 这时候<code>定时Review</code>会更有用，因为看起来更‘节省时间’.</p><p>而<code>提交时Review</code>则可以针对新人，比如你不信任他们的代码或者希望帮助他们提高编码能力。</p><p><strong>相关资源</strong>:</p><ul><li><p>[Code Review 最佳实践](<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTQwNTA3Nw==&amp;mid=400946871&amp;idx=1&amp;sn=5a125337833768d705f9d87ba8cd9fff&amp;scene=21&amp;srcid=0104FLyeXIS6N0EShgDseIfI&amp;key=41ecb04b051110031290b34976240e650f0169d239c89f125162a89c8d3412f2087198612e71fd7685cae9eebe08e295&amp;ascene=0&amp;uin=MTYyMDMzMTAwMA==&amp;devicetype=iMac" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s?__biz=MzIwMTQwNTA3Nw==&amp;mid=400946871&amp;idx=1&amp;sn=5a125337833768d705f9d87ba8cd9fff&amp;scene=21&amp;srcid=0104FLyeXIS6N0EShgDseIfI&amp;key=41ecb04b051110031290b34976240e650f0169d239c89f125162a89c8d3412f2087198612e71fd7685cae9eebe08e295&amp;ascene=0&amp;uin=MTYyMDMzMTAwMA==&amp;devicetype=iMac</a> MacBookPro11,5 OSX OSX 10.10.5 build(14F1509)&amp;version=11020201&amp;pass_ticket=dc5bBckt1XSthRKTIsukYHIcAvKfv0jninbMlYQ5TWnE6XS/rRkdHKlJjNTI2Wsg#wechat_redirect)</p></li><li><p>是否要做 Code Review？与 BAT 资深架构师争论之后的思考</p></li><li><p>一些 Code Review 工具</p></li></ul><h2 id="_6-文档规范" tabindex="-1">6 文档规范 <a class="header-anchor" href="#_6-文档规范" aria-hidden="true">#</a></h2><p>文档对于项目开发和维护、学习、重构、以及知识管理非常重要。</p><p>和写测试一样、大部分开发人员会觉得写文档是一件痛苦的事情，不过只有时间能够证明它的价值。比如对于人员流动比较大的公司，如果有规范的文档体系，转交工作就会变动非常轻松.</p><p><strong>广义的文档不单指‘说明文件’本身，它有很多形式、来源和载体，可以描述一个知识、以及知识形成和迭代的过程</strong>。例如版本库代码提交记录、代码注释、决策和讨论记录、CHANGELOG、示例代码、规范、传统文档等等</p><h3 id="_6-1-建立文档中心" tabindex="-1">6.1 建立文档中心 <a class="header-anchor" href="#_6-1-建立文档中心" aria-hidden="true">#</a></h3><p>我们公司是做 IM 的，所以之前我们优先使用&#39;自己的&#39;通讯工具来分享文档，这种方式有很大问题:</p><ol><li><p>如果没有存档习惯 (比如后端的 API 文档，因为由后端维护，一般不会主动去存档), 文档就可能丢失，而且通讯工具是不会永久保存你的文档的。当丢失文件就需要重新和文档维护者索要</p></li><li><p>糟糕的是文档维护者也是自己手动在本地存档的，这样导致的问题是: 如果工作转交，其他开发者需要花费一点时间来查找; 丢失了就真的没了</p></li><li><p>每一次文档更新要重新发一份, 这很麻烦，而且可能出现漏发的情况, 导致前后不一致.</p></li><li><p>关于知识的学习、以及有意义的讨论记录无法归档。</p></li></ol><p>上面介绍的是一种非常原始的文档共享方式，很多小团队就是这么干的。</p><p><strong>对于项目本身的文档建议放置在关联项目版本库里面，跟随项目代码进行迭代, 当我们在检索或跟踪文档的历史记录时，这种方式是最方便的</strong>。</p><p>然而很多应用是跨越多个团队的，每个团队都会有自己的文档输出 (比如需求文档、系统设计文档、API 文档、配置文档等等)，而且通常也不会在一个版本库里。这时候文档就比较分散。所以一个统一的文档中心是很有必要。</p><p>我们公司现在选择的方案是<code>Git+Markdown</code>，也就是说所有的文档都放置在一个 git 版本库下。之前也考虑过商业的方案，譬如石墨文档、腾讯文档, 但管理层并不信任这些服务。</p><p>大概的 git 项目组织如下:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">规范/</span></span>
<span class="line"><span style="color:#A6ACCD;">A应用/</span></span>
<span class="line"><span style="color:#A6ACCD;">  产品/</span></span>
<span class="line"><span style="color:#A6ACCD;">  设计/</span></span>
<span class="line"><span style="color:#A6ACCD;">  API文档/</span></span>
<span class="line"><span style="color:#A6ACCD;">  测试/</span></span>
<span class="line"><span style="color:#A6ACCD;">  其他/</span></span>
<span class="line"><span style="color:#A6ACCD;">B应用/</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>Git 版本库 (例如 Gitlab) 有很多优势，例如历史记录跟踪、版本化、问题讨论 (可以关联 issue、或者提交)、多人协作、搜索、权限管理(针对不同的版本库或分组为不同人员设置权限) 等等</strong>。</p><p><code>Git+Markdown</code>可以满足开发者的大部分需求。但是 <strong>Git 最擅长的是处理纯文本文件、对于二进制是无能为力的，无法针对这些类型的文档进行在线预览和编辑</strong>。</p><p>所以<code>Git+Markdown</code>并不能满足多样化的文档处理需求，比如思维导图、图表、表格、PPT、白板等需求. 毕竟它不是专业的文档处理工具。所以对于产品、设计人员这些富文档需求场景，通常会按照传统方式或者更专业的工具对文档进行管理.</p><h3 id="_6-2-文档格式" tabindex="-1">6.2 文档格式 <a class="header-anchor" href="#_6-2-文档格式" aria-hidden="true">#</a></h3><p>毫无疑问，对于开发者来说，Markdown 是最适合的、最通用的文档格式。支持版本库在线预览和变更历史跟踪。</p><p>下面这些工具可以提高 Markdown 的开发效率:</p><ul><li><p>可视化编辑器</p></li><li><p><strong>Visual Code</strong>: 大部分代码编辑都支持 Markdown 编辑和预览</p></li><li><p><strong>Mou</strong>: Mac 下的老牌编辑器</p></li><li><p><strong>typora</strong>: 跨平台的 Markdown 编辑器，推荐</p></li><li><p><strong>markdownlint</strong>: 编码检查器</p></li><li><p>扩展 (Visual Studio Code):</p></li><li><p><strong>Markdown All in One</strong>: All you need to write Markdown (keyboard shortcuts, table of contents, auto preview and more)</p></li><li><p><strong>Markdown TOC</strong>: markdown 目录生成，我最常用的 markdown 插件</p></li><li><p>图表绘制工具:</p></li><li><p><strong>drawio</strong> 基于 Web 的图表绘制工具、也有离线客户端</p></li><li><p><strong>KeyNote/PPT</strong> 临时绘图也不错</p></li></ul><h3 id="_6-3-定义文档的模板" tabindex="-1">6.3 定义文档的模板 <a class="header-anchor" href="#_6-3-定义文档的模板" aria-hidden="true">#</a></h3><p>关于如何写好文档，很难通过标准或规范来进行约束，因为它的主观性比较强, 好的文档取决于编辑者的逻辑总结能力、表达能力、以及有没有站在读者的角度去思考问题。</p><p>所以大部分情况下，我们可以为不同类型的文档提供一个模板，通过模板来说明一个文档需要包含哪些内容, 对文档的编写者进行引导.</p><p>例如一个 API 文档可能需要这些内容:</p><ul><li><p>接口的索引</p></li><li><p>接口的版本、变更记录</p></li><li><p>用法和整体描述, 认证鉴权等等</p></li><li><p>描述具体的接口</p></li><li><p>功能说明</p></li><li><p>方法名称或者 URI</p></li><li><p>参数和返回值定义</p></li><li><p>调用示例</p></li><li><p>注意事项等等</p></li></ul><p>具体规范内容因团队而异，这里点到为止.</p><p>扩展:</p><ul><li><p>中文技术文档的写作规范</p></li><li><p>React RFC 模板</p></li></ul><h3 id="_6-4-讨论即文档" tabindex="-1">6.4 讨论即文档 <a class="header-anchor" href="#_6-4-讨论即文档" aria-hidden="true">#</a></h3><p><strong>一般情况下，对于一个开源项目来说除了官方文档，Issues 也是一个很重要的信息来源。在 Issue 中我们可以获取其他开发者遇到的问题和解决方案、给官方反馈 / 投票、关注官方的最新动态、和其他开发者头脑风暴唇枪舌战等等</strong>。</p><p>所以相对于使用 IM，笔者更推荐 Issue 这种沟通模式，因为<strong>它方便归档组织，索引和查找</strong>。而 IM 上的讨论就像流水一样，一去不复返。</p><p>当然两种工具的适用场景不一样，你拿 IM 的使用方式来使用 Issue，Issue 就会变得很水。<strong>Issue 适合做有意义的、目的明确的讨论</strong>。 所以要谴责一下在 Github Issue 上灌水的开发者。</p><p>关于 Issue 有很多妙用，推荐阅读这篇文章 &lt;如何使用 Issue 管理软件项目？&gt;</p><p>现在很多开源项目都引入了 RFC(请求意见稿) 流程 (参考 React 采用新的 RFC 流程, 以及 Vue 最黑暗的一天), 这让开发者有‘翻身农奴、当家做主’的感觉，任何人都可以参与到一个开源项目重大事件的决策之中。<strong>每个 RFC 会说明决策的动机、详细设计、优缺点。除了官方文档之外，这些 RFC 是很有价值的学习资料</strong>。</p><p>我觉得如果不涉及机密，团队应该要让更多人参与到项目的设计和决策中，对于新手可以学到很多东西，而对于发起者也可能有考虑不周的情况。</p><p>那对于企业应用开发, Issue 有用吗?</p><p>当然有用, 比如我们可以将这类话题从 IM 转移到 Issue:</p><ul><li><p>设计方案</p></li><li><p>决策 / 建议</p></li><li><p>新功能、新技术引入</p></li><li><p>重构</p></li><li><p>性能优化</p></li><li><p>规范</p></li><li><p>问题讨论</p></li><li><p>重大事件</p></li><li><p>计划或进度跟踪</p></li><li><p>...</p></li></ul><p>另外 Issue 通常通过标签来进行分类，方便组织和检索:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyKKZrYJsDzWSicUZ1ouia8NRHUodQmTXb5TQzkib3v8Mu3fgl4uR7gxbicQ/640?wx_fmt=png" alt=""></p><h3 id="_6-5-注释即文档" tabindex="-1">6.5 注释即文档 <a class="header-anchor" href="#_6-5-注释即文档" aria-hidden="true">#</a></h3><p><strong>必要和适量的注释对阅读源代码的人来说就是一个路牌, 可以少走很多弯路</strong>.</p><p>关于注释的一些准则，&lt;阿里巴巴 Java 开发手册&gt; 总结得非常好, 推荐基于这个来建立注释规范。另外通过 ESlint 是可以对注释进行一定程度的规范。</p><h3 id="_6-6-代码即文档" tabindex="-1">6.6 代码即文档 <a class="header-anchor" href="#_6-6-代码即文档" aria-hidden="true">#</a></h3><p>现在有很多种工具支持从代码中解析和生成文档, 这可以给开发者简化很多文档维护的工作。</p><p>举个例子，我们经常会遇到修改了代码，但是文档忘记同步的情况。通过‘代码即文档’的方式至少可以<strong>保持文档和代码同步更新</strong>；另外<strong>很多工具会分析代码的数据类型</strong>，自动帮我们生成参数和返回值定义，这也可以减少很多文档编写工作以及出错率。</p><p>比如可以通过下面注释方式来生成组件文档:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">import * as React from &#39;react&#39;;</span></span>
<span class="line"><span style="color:#A6ACCD;">import { Component } from &#39;react&#39;;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">/**</span></span>
<span class="line"><span style="color:#A6ACCD;"> * Props注释</span></span>
<span class="line"><span style="color:#A6ACCD;"> */</span></span>
<span class="line"><span style="color:#A6ACCD;">export interface ColumnProps extends React.HTMLAttributes&lt;any&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  /** prop1 description */</span></span>
<span class="line"><span style="color:#A6ACCD;">  prop1?: string;</span></span>
<span class="line"><span style="color:#A6ACCD;">  /** prop2 description */</span></span>
<span class="line"><span style="color:#A6ACCD;">  prop2: number;</span></span>
<span class="line"><span style="color:#A6ACCD;">  /**</span></span>
<span class="line"><span style="color:#A6ACCD;">   * prop3 description</span></span>
<span class="line"><span style="color:#A6ACCD;">   */</span></span>
<span class="line"><span style="color:#A6ACCD;">  prop3: () =&gt; void;</span></span>
<span class="line"><span style="color:#A6ACCD;">  /** prop4 description */</span></span>
<span class="line"><span style="color:#A6ACCD;">  prop4: &#39;option1&#39; | &#39;option2&#39; | &#39;option3&#39;;</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">/**</span></span>
<span class="line"><span style="color:#A6ACCD;"> * 对组件进行注释</span></span>
<span class="line"><span style="color:#A6ACCD;"> */</span></span>
<span class="line"><span style="color:#A6ACCD;">export class Column extends Component&lt;ColumnProps, {}&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">  render() {</span></span>
<span class="line"><span style="color:#A6ACCD;">    return &lt;div&gt;Column&lt;/div&gt;;</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>相关的工具有:</p><ul><li><p>API 文档</p></li><li><p>Typescript</p><ul><li>tsdoc Typescript 官方的注释文档标准</li><li>typedoc 基于 tsdoc 标准的文档生成器</li></ul></li><li><p>Javascript</p><ul><li>jsdoc Javascript 文档注释标准和生成器</li></ul></li><li><p>后端接口文档</p></li><li><p>Swagger Restful 接口文档规范</p></li><li><p>GraphQL: 这个有很多工具，例如 graphiql, 集成了 Playground 和文档，很先进</p></li><li><p>Easy Mock 一个可视化，并且能快速生成模拟数据的服务</p></li><li><p>组件文档</p></li><li><p>StoryBook 通用的组件开发、测试、文档工具</p></li><li><p>React</p><ul><li>Docz</li><li>Styleguidist</li></ul></li><li><p>Vue</p><ul><li>vue-styleguidist</li><li>有更好的工具请评论告诉我</li></ul></li></ul><p>⬆️ 回到顶部</p><h2 id="_7-ui-设计规范" tabindex="-1">7 UI 设计规范 <a class="header-anchor" href="#_7-ui-设计规范" aria-hidden="true">#</a></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyu6lyYiamMVCygiazW9rcS12qgvQZe2RdmIazoUduRCkOu2DqUeILczRA/640?wx_fmt=png" alt=""></p><p>这是一个容易被忽略的规范类型。笔者就深受其苦，我们公司初期 UI 并不专业，没有所谓的设计规范，这就导致他们设计出来的产品都是东借西凑，前后不统一，多个应用之间的组件不能复用。这搞得我们不得不浪费时间，写很多定制化样式和组件，为他们的不专业买单.</p><p>关于 UI 设计规范的重要性有兴趣的读者可以看这篇文章 &lt;开发和设计沟通有多难？ - 你只差一个设计规范&gt;.</p><p>简单总结一下 UI 设计规范的意义：</p><ul><li><p>提供团队协作效率 (产品和开发)</p></li><li><p>提高组件的复用率. 统一的组件规范可以让组件更好管理</p></li><li><p>保持产品迭代过程中品牌一致性</p></li></ul><p>建立一个定义良好的设计规范需要<code>UI设计和开发</code>的紧密配合，有时候也可以由我们前端来推动。</p><p>比如很多开源的 UI 框架，一开始都是开发者 YY 出来的，并没有设计参与，后来组件库慢慢沉淀成型，UI 设计师才介入规范一下。</p><p>如果你们团队不打算制定自己的 UI 设计规范，则推荐使用现成的开源组件库：</p><ul><li><p>Ant Design</p></li><li><p>Material-UI</p></li><li><p>Element UI</p></li><li><p>WeUI</p></li><li><p>Microsoft Fabric</p></li></ul><p>这些开源组件库都经过良好的设计和沉淀, 而且配套了完善的设计原则、最佳实践和设计资源文件（Sketch 和 Axure），可以帮助业务快速设计出高质量的产品原型。</p><h2 id="_8-测试规范" tabindex="-1">8 测试规范 <a class="header-anchor" href="#_8-测试规范" aria-hidden="true">#</a></h2><p>测试是保障代码质量的重要手段，但是很少有人愿意在这里花太多时间。</p><p>比如笔者，我很少会去给业务代码和组件写单元测试，除非自己对代码非常没有信心，按照我的理念写测试不如将代码写得更简单一点，比如把一个函数拆分为更小的函数，保持单一职责。</p><p>但是<strong>对于一些底层、共享的代码模块还是有测试的必要的</strong>。</p><p>我在不知道测试什么？这些是你需要知道的软件测试类型和常识文章中，列举了一些开发者需要关注的测试类型和常识, 如果按照测试的阶段进行分类，大概是这样子的:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzycmIqZF1MrbuuIUeT5fPUVzH4OstKhTeSLialUYpm6t7YWKKHQdOKzlA/640?wx_fmt=png" alt=""></p><p>其中前端开发者需要关注的主要有以下几种测试类型:</p><ul><li><p><strong>单元测试</strong>: 对独立的软件模块进行测试</p></li><li><p><strong>UI 组件测试</strong>: 包括了快照 (Snapshot) 测试</p></li><li><p><strong>集成测试</strong>: 在单元测试的基础上，将模块组合起来，测试它们的组合性</p></li><li><p><strong>E2E 测试</strong>: 在完整、真实的运行环境下模拟真实用户对应用进行测试。<strong>主要测试前端和后端的协调性</strong></p></li><li><p><strong>兼容性测试</strong>: 上面提到了浏览器兼容规范，在将版本提交给测试 / 发布之前，需要确保能符合兼容性要求</p></li><li><p><strong>性能测试</strong>: 测试和分析是否存在性能问题</p></li><li><p><strong>其他</strong>:</p></li><li><p>安全测试</p></li><li><p>SEO 测试</p></li></ul><p>因为对于小公司来说整个软件开发流程可能没有那么规范，比如很难构建一个完整的端对端测试环境，这些都不是前端团队可以操作的范围, 所以自动化测试很难推行。但是可以根据团队和业务情况逐步进行开展。</p><p>可实施性比较高的, 也比较简单是单元测试，所以本文也重点关注单元测试.</p><h3 id="_8-1-测试的流程" tabindex="-1">8.1 测试的流程 <a class="header-anchor" href="#_8-1-测试的流程" aria-hidden="true">#</a></h3><p>首先要定义一个合适的软件测试流程, 合适的测试流程可以降低开发和测试团队之间的沟通协作成本、提高测试效率。例如我们团队目前的测试流程:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyb0R9vX3HqjhNCJPLHze8u1o4UnLibwPmcE1ekufSQXGceibyTia5NhpLQ/640?wx_fmt=png" alt=""></p><h3 id="_8-2-单元测试" tabindex="-1">8.2 单元测试 <a class="header-anchor" href="#_8-2-单元测试" aria-hidden="true">#</a></h3><p>单元测试有很多<strong>好处</strong>, 比如:</p><ul><li><p><strong>提高信心，适应变化和迭代</strong>. 如果现有代码有较为完善的单元测试，在代码重构时，可以检验模块是否依然可以工作, 一旦变更导致错误，单元测试也可以帮助我们快速定位并修复错误</p></li><li><p><strong>单元测试是集成测试的基础</strong></p></li><li><p><strong>测试即文档</strong>。如果文档不能解决你的问题，在你打算看源码之前，可以查看单元测试。通过这些测试用例，开发人员可以直观地理解程序单元的基础 API</p></li><li><p><strong>提升代码质量。易于测试的代码，一般都是好代码</strong></p></li></ul><p><strong>测什么?</strong></p><p>业务代码或业务组件是比较难以实施单元测试的，一方面它们比较多变、另一方面很多团队很少有精力维护这部分单元测试。所以<strong>通常只要求对一些基础 / 底层的组件、框架或者服务进行测试, 视情况考虑是否要测试业务代码</strong></p><p><strong>测试的准则</strong>:</p><ul><li><p>推荐 Petroware 的 Unit Testing Guidelines, 总结了 27 条单元测试准则，非常受用.</p></li><li><p>另外 &lt;阿里巴巴的 Java 开发手册&gt; 中总结的单元测试准则, 也不错，虽然书名是 Java，准则是通用的.</p></li></ul><p><strong>单元测试指标</strong>:</p><p>一般使用测试覆盖率来量化，尽管对于覆盖率能不能衡量单元测试的有效性存在较多争议。</p><p>大部分情况下还是推荐尽可能提高覆盖率, 比如要求<code>语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100%</code>. 视团队情况而定</p><p>扩展:</p><ul><li>测试覆盖（率）到底有什么用？</li></ul><p><strong>相关工具</strong></p><ul><li><p>Headless Browsers: 无头浏览器是网页自动化的重要运行环境。 常用于功能测试、单元测试、网络爬虫</p></li><li><p>puppeteer</p></li><li><p>Headless Chromium</p></li><li><p>测试框架</p></li><li><p>Jest 🔥Facebook 的单元测试框架. 零配置, 支持组件快照测试、模块 Mock、Spy. 一般场景, 单元测试学它一个就行了</p><ul><li>组件测试</li><li>testing-library 🔥</li><li>Enzyme</li></ul></li><li><p>Intern</p></li><li><p>单元测试</p></li><li><p>AVA</p></li><li><p>Jasmine</p></li><li><p>Mocha</p></li><li><p>Tape</p></li><li><p>断言库</p></li><li><p>Chai</p></li><li><p>expect.js</p></li><li><p>should.js</p></li><li><p>Mock/Stubs/Spies</p></li><li><p>sinon.js</p></li><li><p>代码覆盖率</p></li><li><p>istanbul</p></li><li><p>基准测试</p></li><li><p>benchmark.js</p></li><li><p><a href="http://jsperf.com" target="_blank" rel="noreferrer">jsperf.com</a></p></li></ul><h2 id="_9-异常处理、监控和调试规范" tabindex="-1">9 异常处理、监控和调试规范 <a class="header-anchor" href="#_9-异常处理、监控和调试规范" aria-hidden="true">#</a></h2><p>很多开发者常常误用或者轻视异常的处理, 合理有效的异常处理可以提高应用的健壮性和可用性，另外还可以帮助开发者快速定位异常.</p><h3 id="_9-1-异常处理" tabindex="-1">9.1 异常处理 <a class="header-anchor" href="#_9-1-异常处理" aria-hidden="true">#</a></h3><p>&lt;阿里巴巴的 Java 开发手册&gt; 中总结的异常处理规范对 JavaScript 的异常处理也很有参考意义，比如:</p><ul><li><p>异常不要用来做流程控制，条件控制。</p></li><li><p>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p></li><li><p>catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。不要对大段代码进行 try-catch</p></li><li><p>...</p></li></ul><p>然后再根据 JavaScript 本身的异常处理特点总结一些规范行为, 例如:</p><ul><li><p>不要 throw 非 Error 对象</p></li><li><p>不要忽略异步异常</p></li><li><p>全局监控 Javascript 异常</p></li><li><p>...</p></li></ul><p>资源:</p><ul><li><p>从 1000 + 个项目中总结出来的前 10 个 JavaScript 错误, 以及如何避免它们</p></li><li><p>Javascript 异常处理‘权威’指南</p></li><li><p>前端异常处理最佳实践</p></li></ul><h3 id="_9-2-日志" tabindex="-1">9.2 日志 <a class="header-anchor" href="#_9-2-日志" aria-hidden="true">#</a></h3><p>对于前端来说，日志也不是毫无意义 (很多框架性能优化建议在生产环境移除 console)。尤其是在<strong>生产现场</strong>调试代码时，这时候可贵的控制台日志可以帮助你快速找到异常的线索.</p><p>不过通常我们<strong>只要保留必要的、有意义的日志输出</strong>，比如你不应该将 console.log 放到一个 React 渲染函数中、或者放到一个循环中, <strong>DDos 式的日志信息并不能帮助我们定位问题，反而会影响运行的性能</strong>. 所以需要一个规范来约束日志输出行为, 比如:</p><ul><li><p>避免重复打印日志</p></li><li><p>谨慎地记录日志, 划分日志级别。比如生产环境禁止输出 debug 日志；有选择地输出 info 日志；</p></li><li><p>使用前缀对日志进行分类, 例如: <code>[User] xxxx</code></p></li><li><p>只记录关键信息, 这些信息可以帮助你诊断问题</p></li><li><p>...</p></li></ul><p>扩展资源</p><ul><li><p>debug 适合 Node.js 和浏览器的 debug 日志工具, 支持动态开启日志打印</p></li><li><p>vConsole 移动端调试利器</p></li></ul><h3 id="_9-3-异常监控" tabindex="-1">9.3 异常监控 <a class="header-anchor" href="#_9-3-异常监控" aria-hidden="true">#</a></h3><p>因为程序跑在不受控的环境，所以对于客户端应用来说，异常监控在生产环境是非常重要的，它可以收集各种意料之外生产环境问题，帮助开发者快速定位异常。</p><p>异常监控通常会通过三种方式来收集异常数据:</p><ol><li><p>全局捕获。例如使用 window.onerror, 或者<code>unhandledrejection</code></p></li><li><p>主动上报。在 try/catch 中主动上报.</p></li><li><p>用户反馈。比如弹窗让用户填写反馈信息.</p></li></ol><p>和日志一样，<strong>不是所有‘异常’都应该上报给异常监控系统，譬如一些预料之内的‘异常’</strong>，比如用户输入错误、鉴权失败、网络错误等等. <strong>异常监控主要用来上报一些意料之外的、或者致命性的异常</strong>.</p><p>要做好前端的异常监控其实并不容易，它需要处理这些东西:</p><ul><li><p>浏览器兼容性。</p></li><li><p>碎片收集 (breadcrumbs)。 收集‘灾难’现场的一些线索，这些线索对问题诊断很重要。例如当前用户信息、版本、运行环境、打印的日志、函数调用栈等等</p></li><li><p>调用栈的转换。通常在浏览器运行的压缩优化过的代码，这种调用栈基本没什么可读性，通常需要通过 SourceMap 映射到原始代码. 可以使用这个库: source-map</p></li><li><p>数据的聚合。后端监控系统需要对前端上报的信息进行分析和聚合</p></li></ul><p>对于小团队未必有能力开发这一套系统，所以推荐使用一些第三方工具。例如</p><ul><li><p>Sentry 🔥 免费基本够用</p></li><li><p>FunDebug 付费增强</p></li></ul><p><strong>扩展</strong>:</p><ul><li><p>前端异常监控解决方案研究</p></li><li><p>搭建前端监控系统</p></li></ul><h2 id="_10-前后端协作规范" tabindex="-1">10 前后端协作规范 <a class="header-anchor" href="#_10-前后端协作规范" aria-hidden="true">#</a></h2><p>前端是 Web 的一个细分领域，往往不能脱离后端而存在。所以和后端协作的时间是最长的.</p><h3 id="_10-1-协作流程规范" tabindex="-1">10.1 协作流程规范 <a class="header-anchor" href="#_10-1-协作流程规范" aria-hidden="true">#</a></h3><p>前后端团队经过长期的合作，一般可以总结出一条对于双方开发效率最优的协作流程. 将这个落实为规范，后面的团队成员都遵循这个步调进行协作。</p><p>一个典型的前后端协作流程如下:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzysEkoicIFOShVjrTVyAm8iaCteTZHapQCFLYlrblozSZJaB20fKCQaKKw/640?wx_fmt=png" alt=""></p><ol><li><p>需求分析。参与者一般有前后端、测试、以及产品. 由产品主持，对需求进行宣贯，接受开发和测试的反馈，确保大家对需求有一致的认知</p></li><li><p>前后端开发讨论。讨论应用的一些开发设计，沟通技术点、难点、以及分工问题.</p></li><li><p>设计接口文档。可以由前后端一起设计；或者由后端设计、前端确认是否符合要求</p></li><li><p>并行开发。前后端并行开发，在这个阶段，前端可以先实现静态页面; 或者根据接口文档对接口进行 Mock, 来模拟对接后端接口</p></li><li><p>在联调之前，要求后端做好接口测试</p></li><li><p>真实环境联调。前端将接口请求代理到后端服务，进行真实环境联调。</p></li></ol><h3 id="_10-2-接口规范" tabindex="-1">10.2 接口规范 <a class="header-anchor" href="#_10-2-接口规范" aria-hidden="true">#</a></h3><p>首先应该确定下来的是接口规范。其实使用哪种接口标准是其次，重要的是统一，且要满足前后端的开发效率要求.</p><p>笔者不建议后端去定义自己的接口标准，而应该去选择一些通用的、有标准定义接口形式, 例如:</p><ul><li><p>RESTful: RESTful 是目前使用最为广泛的 API 设计规范, 基于 HTTP 本身的机制来实现. 笔者个人是比较喜欢这个 API 规范，但是我发现很多开发者并不能真正 (或者说没心思) 理解它，设计出来的接口，跟我想象的相差甚远。换句话说，对于 RESTful，开发者之间很难达成一致的理解，容易产生分歧。 因为是使用最广泛的 API 形式，所以社区上有很多工具来对 RESTful 接口进行文档化、测试和模拟.</p></li><li><p>JSONRPC 这是一种非常简单、容易理解的接口规范。相对于 RESTful 我更推荐这个，简单则不容易产生分歧，新手也可以很快接受.</p></li><li><p>GraphQL 🔥 更为先进、更有前景的 API 规范。但是你要说服后端配合你使用这种标准可能很有难度</p></li></ul><p><strong>接口设计需要注意的点</strong>:</p><ul><li><p>明确区分是正常还是异常, 严格遵循接口的异常原语. 上述接口形式都有明确的异常原语，比如 JSONRPC，当出现异常时应该返回<code>错误对象</code>响应，而不是在正常的响应体中返回错误代码. 另外要规范化的错误码, HTTP 响应码就是一个不错的学习对象</p></li><li><p>明确数据类型。很多后端写的接口都是 string 和 number 不分的，如果妥协的话、前端就需要针对这个属性做特殊处理，这也可能是潜在的 bug</p></li><li><p>明确空值的意义。比如在做更新操作是，空值是表示重置，还是忽略更新？</p></li><li><p>响应避免冗余的嵌套。</p></li><li><p>接口版本化，保持向下兼容。就像我们上文的‘语义化版本规范’说的，对于后端来说，API 就是公共的接口. 公共暴露的接口应该有一个版本号，来说明当前描述的接口做了什么变动，是否向下兼容。 现在前端代码可能会在客户端被缓存，例如小程序。如果后端做了 break change，就会影响这部分用户。</p></li></ul><h3 id="_10-3-接口文档规范" tabindex="-1">10.3 接口文档规范 <a class="header-anchor" href="#_10-3-接口文档规范" aria-hidden="true">#</a></h3><p>后端通过接口文档向前端暴露接口相关的信息。通常需要包含这些信息：</p><ul><li><p>版本号</p></li><li><p>文档描述</p></li><li><p>服务的入口. 例如基本路径</p></li><li><p>测试服务器. 可选</p></li><li><p>简单使用示例</p></li><li><p>安全和认证</p></li><li><p>具体接口定义</p></li><li><p>方法名称或者 URL</p></li><li><p>方法描述</p></li><li><p>请求参数及其描述，必须说明类型 (数据类型、是否可选等)</p></li><li><p>响应参数及其描述, 必须说明类型 (数据类型、是否可选等)</p></li><li><p>可能的异常情况、错误代码、以及描述</p></li><li><p>请求示例，可选</p></li></ul><p><strong>人工维护导致的问题</strong>:</p><p>上文‘代码即文档’就提到了人工维护接口文档可能导致代码和文档不同步问题。</p><p>如果可以从代码或者规范文档 (例如 OpenAPI 这类 API 描述规范) 中生成接口文档，可以解决实现和文档不一致问题, 同时也可以减少文档编写和维护的投入.</p><h3 id="_10-4-接口测试与模拟" tabindex="-1">10.4 接口测试与模拟 <a class="header-anchor" href="#_10-4-接口测试与模拟" aria-hidden="true">#</a></h3><p>为了做到高效率的前后端并行开发，接口的测试与模拟是必要的。</p><ul><li><p>前端要求后端在联调之前，需要测试验证好自己的接口是否可以正常工作。而不是在联调期间，把前端当‘接口测试员’，阻塞接口联调进度</p></li><li><p>另外前端需要在后端接口未准备好之前，通过接口模拟的方式，来编写业务逻辑代码。</p></li></ul><p>针对接口测试与模拟，存在下图这样一个理想的模型:</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzy9iaZ4KTLjNKVL4kbupFWLtEQ8gibvgbd5l0NTI2IOg6dc41MIZpCGWCw/640?wx_fmt=png" alt=""></p><p>一切从定义良好的接口文档出发，生成<code>Mock Server</code>和<code>Mock Client</code>, Mock Server 给前端提供模拟数据，而 Mock Client 则辅助后端对它们的接口进行测试.</p><p>资源:</p><ul><li><p>RESTful</p></li><li><p>Swagger 这是最为接近上面理想模型的一个解决方案</p></li><li><p>JSON Server 快速生成 JSON mock 服务器</p></li><li><p>Easy Mock 可视化的、在线的接口 mock 服务</p></li><li><p>GraphQl</p></li><li><p>GraphQL Faker</p></li><li><p>graphql-tools</p></li><li><p>模拟数据生成</p></li><li><p>faker.js 🔥 强大的模拟数据生成工具，支持 Node 和浏览器</p></li><li><p>Mock.js 数据生成和模拟工具</p></li></ul><h2 id="_11-培训-知识管理-技术沉淀" tabindex="-1">11 培训 / 知识管理 / 技术沉淀 <a class="header-anchor" href="#_11-培训-知识管理-技术沉淀" aria-hidden="true">#</a></h2><p>我觉得一个团队的知识管理是非常重要的. 你要问一个刚入行的新手加入团队希望得到什么？很多人的回答是&#39;学习&#39;, 希望自己的技术可以更加精进, 钱倒还是其次。</p><p>然而现实是目前很多公司的氛围并不是这样的，一天到晚写业务代码、工作量大、每天做重复的事情，而且还加班，工作多年技术也没感觉有多少进步, 确实会让人非常沮丧。包括笔者也是这样的。</p><p>所以为了改善这种情况，我来聊聊最近在‘小团队’做的一些尝试.</p><h3 id="_11-1-新人培训" tabindex="-1">11.1 新人培训 <a class="header-anchor" href="#_11-1-新人培训" aria-hidden="true">#</a></h3><p>如果团队有规范的新成员培训手册，可以节省很多培训的时间，避免每次重复口述一样的内容。培训手册包含以下内容:</p><ul><li><p><strong>产品架构与组织架构</strong>. 介绍公司背景和产品，一般组织的团队结构和产品的架构是相关联的. 以笔者所在公司为例, 主要产品是即时通信: <img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyLmThGE5g0MxDZdib0ISNdepWTzpo2qXXtw1EQNhFwe77O4iaGqjJzkvA/640?wx_fmt=png" alt=""></p></li><li><p><strong>产品研发流程</strong>: 介绍产品开发和迭代会涉及到的流程、以及团队之间的协作衔接，例如: <img src="https://mmbiz.qpic.cn/mmbiz_png/U0WXqkJLdLSIM3BCr08YNh2WSFUOgvzyKyiaK0fiav0ZnA4qiakLPBGLUswwJkZu0IGGL6uA7DxGtPpI1ic1QG1VtA/640?wx_fmt=png" alt=""></p></li><li><p><strong>工作范围</strong>: 团队成员的职责范围</p></li><li><p><strong>建立资源索引</strong>: 开发需要设计到的资源，比如各种文档地址、研发系统入口 (例如 gitlab、bug 跟踪系统、文件共享、发布平台、开发 / 测试环境、监控系统)、协作规范等等。将这些资源整理好可以减少不必要的沟通成本</p></li><li><p><strong>规范</strong>: 即本文的主体&#39;前端协作规范&#39;。有规范可循，可以让成员以较快的速度入手开发、同时也减少培训成本投入。</p></li></ul><p>培训手册将可以文档具象化的内容整理为文档，和上文说到的 Code Review 一样，一些东西无法通过文档来说明，所以我们一般会搭配一个‘培训导师’，在试用期间，一对一辅导。</p><h3 id="_11-2-营造技术氛围" tabindex="-1">11.2 营造技术氛围 <a class="header-anchor" href="#_11-2-营造技术氛围" aria-hidden="true">#</a></h3><ul><li><p><strong>鼓励成员写技术博客，或者建立自己的团队专栏</strong>. 写一篇好的文章不容易</p></li><li><p><strong>鼓励参与开源项目</strong></p></li><li><p><strong>建立面试题库</strong> 组织一起解一些面试题或算法题，加深对知识点的理解</p></li><li><p><strong>定期的专题分享</strong>. 鼓励团队成员定期进行专题学习和研究，编写技术博客，并将学习的成果分享给其他成员. 这是一种抱团取暖的学习方式，旨在帮助团队成员一起学习和成长。 比如开发老手可以分享自己的经验，研究更深层次的技术；新手则可以研究某些开发技巧、新技术，例如 CSS Grid，svg 动画等等。推荐团队成员有个明确的研究领域，这样分工合作可以学习到更多东西. <strong>专题怎么来?</strong></p></li><li><p>专题请求. 可以请求其他成员完成专题，比如比较深的知识，可以要求团队比较有经验的进行学习分享</p></li><li><p>学习总结.</p></li><li><p>项目回顾</p></li><li><p>难点攻克</p></li><li><p>项目规范</p></li><li><p>工具使用</p></li><li><p><strong>落实和完善开发规范</strong>. 规范本身就是团队知识沉淀的一种直接输出</p></li><li><p><strong>图书分享</strong>. 和离散的文章或教程相比，图书的知识会比较系统，另外很多经典的图书是要静下来好好欣赏的。</p></li><li><p><strong>鼓励重构和持续优化代码</strong></p></li><li><p><strong>抽象一套基础库或框架，减少重复工作, 提高工作效率</strong>. 不加班先从提高工作效率开始</p></li></ul></div></div></main><!--[--><!--]--><footer class="VPDocFooter" data-v-192b9b3b data-v-f45da98a><!----><div class="prev-next" data-v-f45da98a><div class="pager" data-v-f45da98a><!----></div><div class="pager" data-v-f45da98a><a class="pager-link next" href="/vue3-admin-boilerplate/other/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83.html" data-v-f45da98a><span class="desc" data-v-f45da98a>下一篇</span><span class="title" data-v-f45da98a>怎么落实规范</span></a></div></div></footer><!--[--><!--]--></div></div></div></div></div><footer class="VPFooter has-sidebar" data-v-57716dfc data-v-5edab1d2><div class="container" data-v-5edab1d2><!----><p class="copyright" data-v-5edab1d2>Copyright @ 2021-2022 xxx. All Rights Reserved</p></div></footer><!--[--><!--]--></div></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"basic_component.md\":\"f1479187\",\"basic_index.md\":\"7dd2f8e7\",\"basic_mock.md\":\"9300101c\",\"basic_request.md\":\"e219f0fb\",\"basic_style.md\":\"a544eee4\",\"basic_svg.md\":\"9f2a195b\",\"basic_version.md\":\"e45f8e79\",\"guid_index.md\":\"187e2638\",\"guid_readme.md\":\"a0cb64d1\",\"index.md\":\"a79857d6\",\"other_docker_nginx.md\":\"bd1550d1\",\"other_index.md\":\"41e52db8\",\"other_代码脱敏.md\":\"4a874a53\",\"other_前端技术规范.md\":\"268dc573\",\"other_前端规范是什么.md\":\"52fcf658\",\"other_命名规范.md\":\"c5d21498\",\"recommend_index.md\":\"46997798\",\"recommend_technology_stack.md\":\"be6e9ac8\",\"recommend_vscode.md\":\"7eecca57\",\"standard_code.md\":\"55c0d13d\",\"standard_comments.md\":\"250f14bf\",\"standard_css.md\":\"84a45fc9\",\"standard_doc.md\":\"ad2e5671\",\"standard_format.md\":\"c6ca1a31\",\"standard_git.md\":\"f7048989\",\"standard_ignore.md\":\"5ee48402\",\"standard_index.md\":\"0149a331\",\"standard_javascript.md\":\"7ceaccd1\",\"standard_name.md\":\"bc156cb0\",\"standard_structure.md\":\"df4485a9\",\"vite-plugins_pages_layouts.md\":\"f743dc1c\",\"vite-plugins_常见插件介绍.md\":\"97ecfb55\"}")</script>
    <script type="module" async src="/vue3-admin-boilerplate/assets/app.1cd7dc09.js"></script>
    
  </body>
</html>